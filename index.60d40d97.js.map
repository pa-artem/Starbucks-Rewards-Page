{"mappings":";;;;;AAAA,IAAMA,EAAkB,+LAalBC,EAAoCD,EAAmBE,KAAnB,KAEpCC,EACJ,oBAAOC,QAAP,aAEIA,QAAQC,UAAUF,SAClBC,QAAQC,UAAUC,mBAClBF,QAAQC,UAAUE,sBAElBC,EAAa,SAAaC,EAAIC,EAAkBC,GACpD,IAAIC,EAAaC,MAAMR,UAAUS,MAAMC,MACrCN,EAAGO,iBAAiBf,WAElBS,GAAoBP,EAAQc,KAAKR,EAAIR,IACvCW,EAAWM,QAAQT,GAErBG,EAAaA,EAAWD,OAAOA,IAQ3BQ,EAAW,SAAaC,GAC5B,IAAMC,EAAeC,SAASF,EAAKG,aAAL,YAA+B,IAE7D,OAAKC,MAAMH,GAPU,SAAaD,SAC3B,SAAAA,EAAKK,gBAYRC,CAAkBN,GACb,EASN,UAAAA,EAAKO,UACJ,UAAAP,EAAKO,UACL,YAAAP,EAAKO,UAC2B,OAAlCP,EAAKG,aAAL,YAKKH,EAAKQ,SAHH,EApBAP,GA0BLQ,EAAoB,SAAaC,EAAGC,UACjCD,EAAEF,WAAaG,EAAEH,SACpBE,EAAEE,cAAgBD,EAAEC,cACpBF,EAAEF,SAAWG,EAAEH,UAGfK,EAAO,SAAab,SACjB,UAAAA,EAAKc,SAgERC,EAAkB,SAAaf,UAJxB,SAAaA,UACjBa,EAAQb,IAAS,UAAAA,EAAKgB,KAItBC,CAAQjB,KAzCI,SAAaA,GAChC,IAAKA,EAAKkB,KAAV,OACS,EAET,IAQIC,EAREC,EAAapB,EAAKqB,MAAQrB,EAAKsB,cAE/BC,EAAW,SAAaL,UACrBE,EAAWxB,iBAAX,6BAC0BsB,EAA/B,OAKJ,GACE,oBAAOM,aACP,IAAOA,OAAOC,KACd,mBAAOD,OAAOC,IAAIC,OAElBP,EAAWI,EAAYC,OAAOC,IAAIC,OAAO1B,EAAKkB,gBAG5CC,EAAWI,EAAYvB,EAAKkB,MAD9B,MAESS,UAEPC,QAAQC,MAAR,2IAEEF,EAAIG,UAEC,EAIX,IAAMC,EAxCa,SAAaC,EAAOX,OAClC,IAAIY,EAAI,EAAGA,EAAID,EAAME,OAAQD,IAChC,GAAID,EAAMC,GAAGF,SAAWC,EAAMC,GAAGZ,OAASA,EAA1C,OACSW,EAAMC,GAqCDE,CAAgBhB,EAAUnB,EAAKqB,aACvCU,GAAWA,IAAY/B,EAQNoC,CAAgBpC,IAwErCqC,EAA+B,SAAaC,EAAStC,GACzD,QACEA,EAAKuC,UAxIU,SAAavC,UACvBa,EAAQb,IAAS,WAAAA,EAAKgB,KAwI3BwB,CAAcxC,IAxEJ,SAAaA,EAAMyC,GAC/B,GAAI,WAAAC,iBAAiB1C,GAAM2C,WAA3B,OACS,EAGT,IACMC,EADkB7D,EAAQc,KAAKG,EAAb,iCACmBA,EAAK6C,cAAgB7C,EAChE,GAAIjB,EAAQc,KAAK+C,EAAb,yBAAA,OACK,EAET,GAAKH,GAA4B,SAAZA,GAOd,GAAgB,kBAAZA,EAAkC,CAC3C,IAAAK,EAA0B9C,EAAK+C,wBAAvBC,EAARF,EAAQE,MAAOC,EAAfH,EAAeG,cACE,IAAVD,GAA0B,IAAXC,QATxB,KACSjD,GAAM,CACX,GAAI,SAAA0C,iBAAiB1C,GAAMkD,QAA3B,OACS,EAETlD,EAAOA,EAAK6C,qBAOT,EAmDLM,CAASnD,EAAMsC,EAAQG,eAtID,SAAazC,SAEnC,YAAAA,EAAKc,SACLrB,MAAMR,UAAUS,MACbC,MAAMK,EAAKoD,UACXC,MAFH,SAESC,SAAU,YAAAA,EAAMxC,WAmIzByC,CAAqBvD,IA/CG,SAAaA,GACvC,GACEa,EAAQb,IACR,WAAAA,EAAKc,SACL,aAAAd,EAAKc,SACL,WAAAd,EAAKc,YAEL,IAAI0C,EAAaxD,EAAK6C,cACfW,GAAY,CACjB,GAAI,aAAAA,EAAW1C,SAA0B0C,EAAWjB,SAAU,KAMvD,IAAIN,EAAI,EAAGA,EAAIuB,EAAWJ,SAASlB,OAAQD,IAAK,CACnD,IAAMqB,EAAQE,EAAWJ,SAASK,KAAKxB,GACvC,GAAI,WAAAqB,EAAMxC,QACR,OAAIwC,EAAMI,SAAS1D,UAWhB,EAGTwD,EAAaA,EAAWX,qBAMrB,EAULc,CAAuB3D,KAOrB4D,EAA8B,SAAatB,EAAStC,GACxD,SACGqC,EAAgCC,EAAStC,IAC1Ce,EAAmBf,IACnBD,EAAYC,GAAQ,IA+DlB6D,EAA6CjF,EAChDkF,OADgD,UAEhDhF,KAFgD,KAI7CiF,EAAW,SAAa/D,EAAMsC,GAElC,GADAA,EAAUA,GAAO,IACZtC,EACH,MAAM,IAAIgE,MAAJ,oBAER,OAAuD,IAAnDjF,EAAQc,KAAKG,EAAM6D,IAGhBxB,EAAgCC,EAAStC,0VC9SlD,IACQiE,EADFC,GACED,EAAS,IAEbE,aADK,SACQC,GACX,GAAIH,EAAU/B,OAAS,EAAG,CACxB,IAAMmC,EAAaJ,EAAUA,EAAU/B,OAAS,GAC5CmC,IAAeD,GACjBC,EAAWC,QAIf,IAAMC,EAAYN,EAAUO,QAAQJ,IAClB,IAAdG,GAIFN,EAAUQ,OAAOF,EAAW,GAH5BN,EAAUS,KAAKN,IAQnBO,eAnBK,SAmBUP,GACb,IAAMG,EAAYN,EAAUO,QAAQJ,IAClB,IAAdG,GACFN,EAAUQ,OAAOF,EAAW,GAG1BN,EAAU/B,OAAS,GACrB+B,EAAUA,EAAU/B,OAAS,GAAG0C,aAsBlCC,EAAK,SAAaC,UACfC,WAAWD,EAAI,IAKlBE,EAAS,SAAaC,EAAKH,GAC/B,IAAII,GAAM,SAEVD,EAAIE,OAAJ,SAAoBC,EAAOnD,GACzB,OAAI6C,EAAGM,KACLF,EAAMjD,GACC,MAMJiD,GAUHG,EAAc,SAAaD,OAAkB,IAAAE,EAAAC,UAAArD,OAARsD,EAAQ,IAAA/F,MAAA6F,EAAA,EAAAA,EAAA,EAAA,GAAAG,EAAA,EAAAA,EAAAH,EAAAG,IAARD,EAAAA,EAAAA,GAAAA,UAAAA,SAClC,mBAAOJ,EAAuBA,EAAKzF,WAAL,EAAS6F,GAAUJ,GAGpDM,EAAe,SAAaC,UAQzBA,EAAMC,OAAOC,YAAc,mBAAOF,EAAMG,aAC3CH,EAAMG,eAAe,GACrBH,EAAMC,QAGNG,EAAe,SAAaC,EAAUC,GAC1C,IAgCI7B,EAhCE8B,GAAMD,MAAAA,OAAA,EAAAA,EAAaE,WAAYA,SAE/BC,iWAANC,CAAA,CACEC,yBAAyB,EACzBC,mBAAmB,EACnBC,mBAAmB,GAChBP,GAGCQ,EAAK,CAETC,WAAU,GASVC,eAAc,GAEdC,4BAA6B,KAC7BC,wBAAyB,KACzBC,QAAQ,EACRC,QAAQ,EAIRC,4BAAwBC,GAKpBC,EAAS,SAAIC,EAAuBC,EAAYC,UAC7CF,QACiCF,IAAtCE,EAAsBC,GACpBD,EAAsBC,GACtBhB,EAAOiB,GAAoBD,IAG3BE,EAAiB,SAAaC,YAEhCA,IACAd,EAAMC,WAAWrD,MAAjB,SAAuBmE,UAAcA,EAAU9D,SAAS6D,QAiBtDE,EAAgB,SAAaL,GACjC,IAAIM,EAActB,EAAOgB,GAEzB,GAAI,mBAAOM,EAA4B,KAAA,IAAAC,EAAApC,UAAArD,OAHSsD,EAGT,IAAA/F,MAAAkI,EAAA,EAAAA,EAAA,EAAA,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAHSpC,EAAAA,EAAAA,GAAAA,UAAAA,GAI9CkC,EAAcA,EAAW/H,WAAX,EAAe6F,GAG/B,IAAKkC,EAAa,CAChB,QAAoBT,IAAhBS,IAA6C,IAAhBA,EAAjC,OACSA,EAIT,MAAM,IAAI1D,MAAJ,IAAAF,OACCsD,EADD,iEAKR,IAAIpH,EAAO0H,EAEX,GAAI,iBAAOA,KACT1H,EAAOkG,EAAI2B,cAAcH,IAEvB,MAAM,IAAI1D,MAAJ,IAAAF,OACCsD,EADD,iDAMHpH,GAGH8H,EAAmB,WACvB,IAAI9H,EAAOyH,EAAgB,gBAG3B,IAAa,IAATzH,EAAJ,OACS,EAGT,QAAaiH,IAATjH,EAEF,GAAIsH,EAAkBpB,EAAI6B,eACxB/H,EAAOkG,EAAI6B,kBACN,CACL,IAAMC,EAAqBvB,EAAME,eAAe,GAKhD3G,EAHEgI,GAAsBA,EAAmBC,mBAGfR,EAAgB,iBAIhD,IAAKzH,EACH,MAAM,IAAIgE,MAAJ,uEAKDhE,GAGHkI,EAAmB,WAkBvB,GAjBAzB,EAAME,eAAiBF,EAAMC,WAC1ByB,KADoB,SACfX,GACJ,IDWuBlF,EAGvB8F,EACAC,ECfMC,GDcNF,EAAgB,GAChBC,EAAgB,GAEHjJ,ECjBkBoI,GDYrClF,EAAUA,GAAO,IAOPhD,iBACRsE,EAA+B2E,KAAK,KAAMjG,IAGjCkG,SAAX,SAA6BC,EAAWxG,GACtC,IAAMyG,EAAoB3I,EAAY0I,GACZ,IAAtBC,EACFN,EAAiB1D,KAAK+D,GAEtBJ,EAAiB3D,KAAjB,CACE9D,cAAeqB,EACfzB,SAAUkI,EACV1I,KAAMyI,OAKUJ,EACnBM,KAAKlI,GACL0H,KAFmB,SAEdzH,UAAMA,EAAEV,QACb8D,OAAOsE,ICrCJ,GAAIE,EAAcpG,OAAS,EAA3B,MAAA,CAEIsF,UAAAA,EACAS,kBAAmBK,EAAc,GACjCM,iBAAkBN,EAAcA,EAAcpG,OAAS,OAM5D3C,QAdoB,SAcZsJ,WAAYA,KAIrBpC,EAAME,eAAezE,QAAU,IAC9BuF,EAAgB,iBAEjB,MAAM,IAAIzD,MAAJ,wGAMJ8E,EAAQ,SAARA,EAAqB9I,IACZ,IAATA,GAIAA,IAASkG,EAAI6B,gBAIZ/H,GAASA,EAAK+I,OAKnB/I,EAAK+I,MAAL,CAAaC,gBAAiB5C,EAAO4C,gBACrCvC,EAAMI,wBAA0B7G,EArOb,SAAaA,UAEhCA,EAAKc,SACL,UAAAd,EAAKc,QAAQmI,eACb,mBAAOjJ,EAAKkJ,OAmORC,CAAkBnJ,IACpBA,EAAKkJ,UARLJ,EAAShB,OAYPsB,EAAkB,SAAaC,GACnC,IAAMrJ,EAAOyH,EAAgB,iBAAmB4B,UACzCrJ,IAAuB,IAATA,GAAyBqJ,GAK1CC,EAAgB,SAAaC,GACjC,IAAM3D,EAASF,EAAgB6D,GAE3BjC,EAAkB1B,KAKlBP,EAAee,EAAOoD,wBAAyBD,GAEjDnF,EAAKqF,WAAL,CAYEC,YAAatD,EAAOE,0BAA4BvC,EAAY6B,KAQ5DP,EAAee,EAAOuD,kBAAmBJ,IAM7CA,EAAEK,mBAIEC,EAAY,SAAaN,GAC7B,IAAM3D,EAASF,EAAgB6D,GACzBO,EAAkBxC,EAAkB1B,GAGtCkE,GAAmBlE,aAAkBmE,SACnCD,IACFrD,EAAMI,wBAA0BjB,IAIlC2D,EAAES,2BACFlB,EAASrC,EAAMI,yBAA2BiB,OA6GxCmC,EAAQ,SAAaV,GACzB,GA7Ye,SAAaA,SACvB,WAAAA,EAAEW,KAAoB,QAAAX,EAAEW,KAA+B,KAAdX,EAAEY,QA6Y9CC,CAAcb,KACkC,IAAhDlE,EAAee,EAAOG,kBAAmBgD,UAEzCA,EAAEK,sBACFxF,EAAKqF,cA9YK,SAAaF,SACpB,QAAAA,EAAEW,KAA+B,IAAdX,EAAEY,SAiZtBE,CAAWd,IA/GH,SAAaA,GACzB,IAAM3D,EAASF,EAAgB6D,GAC/BrB,IAEA,IAAIoC,EAAkB,KAEtB,GAAI7D,EAAME,eAAezE,OAAS,EAAG,CAInC,IAAMqI,EAAiBvF,EAAUyB,EAAME,gBAAP,SAAhC6D,UAAuDA,EAAGhD,UAC9C9D,SAASkC,MAGrB,GAAI2E,EAAiB,EAKjBD,EAFEf,EAAEkB,SAGFhE,EAAME,eAAeF,EAAME,eAAezE,OAAS,GAChD0G,iBAGanC,EAAME,eAAe,GAAGsB,uBAEvC,GAAIsB,EAAEkB,SAAU,CAIrB,IAAIC,EAAoB1F,EACtByB,EAAME,gBADyB,SAAjCgE,GAEE,IAAG1C,EAAH0C,EAAG1C,yBAAwBrC,IAAWqC,KAaxC,GATEyC,EAAoB,GACpBjE,EAAME,eAAe4D,GAAgB/C,YAAc5B,IAKnD8E,EAAoBH,GAGlBG,GAAqB,EAAG,CAI1B,IAAME,EACkB,IAAtBF,EACIjE,EAAME,eAAezE,OAAS,EAC9BwI,EAAoB,EAG1BJ,EADyB7D,EAAME,eAAeiE,GACXhC,sBAEhC,CAIL,IAAIiC,EAAmB7F,EACrByB,EAAME,gBADwB,SAAhCmE,GAEE,IAAGlC,EAAHkC,EAAGlC,wBAAuBhD,IAAWgD,KAavC,GATEiC,EAAmB,GACnBpE,EAAME,eAAe4D,GAAgB/C,YAAc5B,IAKnDiF,EAAmBN,GAGjBM,GAAoB,EAAG,CAIzB,IAAMD,EACJC,IAAqBpE,EAAME,eAAezE,OAAS,EAC/C,EACA2I,EAAmB,EAGzBP,EADyB7D,EAAME,eAAeiE,GACX3C,yBAKvCqC,EAAkB7C,EAAgB,iBAGhC6C,IACFf,EAAEK,iBACFd,EAASwB,IAgBTS,CAASxB,IAKPyB,EAAU,SAAazB,GAC3B,IAAIlE,EAAee,EAAOoD,wBAAyBD,GAAnD,CAIA,IAAM3D,EAASF,EAAgB6D,GAE3BjC,EAAkB1B,IAIlBP,EAAee,EAAOuD,kBAAmBJ,KAI7CA,EAAEK,iBACFL,EAAES,8BAOEiB,EAAY,WAChB,GAAKxE,EAAMK,cAKX5C,EAAiBC,aAAaC,GAI9BqC,EAAMO,uBAAyBZ,EAAOI,kBAClC3B,GAAK,WACHiE,EAAShB,QAEXgB,EAAShB,KAEb5B,EAAIgF,iBAAJ,UAAgCrB,GAAc,GAC9C3D,EAAIgF,iBAAJ,YAAkC5B,EAAlC,CACE6B,SAAS,EACTC,SAAS,IAEXlF,EAAIgF,iBAAJ,aAAmC5B,EAAnC,CACE6B,SAAS,EACTC,SAAS,IAEXlF,EAAIgF,iBAAJ,QAA8BF,EAA9B,CACEG,SAAS,EACTC,SAAS,IAEXlF,EAAIgF,iBAAJ,UAAgCjB,EAAhC,CACEkB,SAAS,EACTC,SAAS,IAGJhH,GAGHiH,EAAe,WACnB,GAAK5E,EAAMK,cAIXZ,EAAIoF,oBAAJ,UAAmCzB,GAAc,GACjD3D,EAAIoF,oBAAJ,YAAqChC,GAAkB,GACvDpD,EAAIoF,oBAAJ,aAAsChC,GAAkB,GACxDpD,EAAIoF,oBAAJ,QAAiCN,GAAY,GAC7C9E,EAAIoF,oBAAJ,UAAmCrB,GAAU,GAEtC7F,UAOTA,EAAI,CACFmH,SADK,SACIC,GACP,GAAI/E,EAAMK,OAAV,OAAA2E,KAIA,IAAMC,EAAaxE,EAAUsE,EAAD,cACtBG,EAAiBzE,EAAUsE,EAAD,kBAC1BI,EAAoB1E,EAAUsE,EAAD,qBAE9BI,GACH1D,IAGFzB,EAAMK,QAAS,EACfL,EAAMM,QAAS,EACfN,EAAMG,4BAA8BV,EAAI6B,cAEpC2D,GACFA,IAGF,IAAMG,EAAgB,WAChBD,GACF1D,IAEF+C,IACIU,GACFA,KAIJ,OAAIC,GACFA,EAAkBnF,EAAMC,WAAW5C,UAAUgI,KAC3CD,EACAA,UAKJA,WAIFpC,WA5CK,SA4CMsC,GACT,IAAKtF,EAAMK,OAAX,OAAA2E,KAIAO,aAAavF,EAAMO,wBACnBP,EAAMO,4BAAyBC,EAE/BoE,IACA5E,EAAMK,QAAS,EACfL,EAAMM,QAAS,EAEf7C,EAAiBS,eAAeP,GAEhC,IAAM6H,EAAe/E,EAAU6E,EAAD,gBACxBG,EAAmBhF,EAAU6E,EAAD,oBAC5BI,EAAsBjF,EAC1B6E,EADmC,uBAKjCE,GACFA,IAGF,IAAMvC,EAAcxC,EAClB6E,EAD2B,cAAA,2BAMvBK,EAAkB,WACtBvH,GAAK,WACC6E,GACFZ,EAASM,EAAmB3C,EAAMG,8BAEhCsF,GACFA,QAKN,OAAIxC,GAAeyC,GACjBA,EACE/C,EAAmB3C,EAAMG,8BACzBkF,KAAKM,EAAoBA,UAI7BA,WAIF9H,MAjGK,WAkGH,OAAImC,EAAMM,SAAWN,EAAMK,SAI3BL,EAAMM,QAAS,EACfsE,KALAI,MAUF7G,QA5GK,WA6GH,OAAK6B,EAAMM,QAAWN,EAAMK,QAI5BL,EAAMM,QAAS,EACfmB,IACA+C,UANAQ,MAWFY,wBAxHK,SAwHmBC,GACtB,IAAMC,EAAe,GAAMzI,OAAOwI,GAAmB/M,OAAOiN,gBAE5D/F,EAAMC,WAAa6F,EAAgBpE,KAAhB,SAAqBZ,SACtC,iBAAOA,EAAuBrB,EAAI2B,cAAcN,GAAWA,KAGzDd,EAAMK,QACRoB,YAQDmE,wBAAwBrG,GAEtB5B,GC9pBT+B,SAASvG,iBAAgB,wBAAyB4I,SAASiE,IACzD,MAAMC,EAAYD,EAAQE,QAAQC,aAC5BC,EAAoB1G,SAAS2G,eAAeL,EAAQE,QAAQI,iBAElEN,EAAQvB,iBAAgB,SAAQ,KAC9B2B,EAAkBG,UAAUC,OAAOP,SAIvC,MAAMQ,EAAe/G,SAAS2G,eAAc,kBAC5CI,EAAanE,QACb,MAAMoE,EAAmBC,EAA0BF,EAAY,CAAIvD,mBAAmB,IACtFwD,EAAiB5B,WACe2B,EAAarF,cAAa,iCAClCqD,iBAAgB,SAAQ,KAC9CiC,EAAiB1D,gBAEnByD,EAAahC,iBAAgB,WAAavF,IAC3B,WAATA,EAAMuE,KACRgD,EAAaF,UAAUC,OAAM,4BAIjC9G,SAASvG,iBAAgB,8BAA+B4I,SAASjB,IAC/DA,EAAQ/G,UAAW,KAGrB,MAAM6M,EAAWlH,SAAS0B,cAAa,cAEjCyF,EAAanH,SAAS0B,cAAa,qCACnC0F,EAAgBpH,SAAS0B,cAAa,oBAEtC2F,EAASF,EAAWzF,cAAa,qBACjC4F,EAAYH,EAAWzF,cAAa,wBACpC6F,EAAYJ,EAAWzF,cAAa,wBAEpC8F,EAAUxH,SAAS0B,cAAa,iBAChC+F,EAAoBzH,SAAS0B,cAAa,kCAC1CgG,EAAqB1H,SAAS0B,cAAa,iCAE3CiG,EAAoBC,IACxB,QAAkB9G,IAAd8G,EAAuB,MAAA,OAI3B,IAAIC,GAAmB,SACvBD,EAAUzJ,aAGJ0J,EACFA,GAAmB,EAEnBD,EAAUE,UAEZF,EAAUG,SAIRC,EAAgB,CACpBC,UAAS,SACTC,KAAI,WACJC,SAAU,IACVC,OAAM,eAGFC,EAAkBV,EACtBN,EAAOiB,QAAO,EAGRC,UAAS,SAGTA,UAAS,kBACTC,OAAQ,KAGRD,UAAS,kBACTC,OAAQ,KAGRD,UAAS,kCAGbP,IAIES,EAAqBd,EACzBL,EAAUgB,QAAO,EAGXC,UAAS,SAGTA,UAAS,OACTC,OAAQ,KAGRD,UAAS,OACTC,OAAQ,KAGRD,UAAS,kBAGbP,IAIEU,EAAqBf,EACzBJ,EAAUe,QAAO,EAGXC,UAAS,SAGTA,UAAS,mBACTC,OAAQ,KAGRD,UAAS,mBACTC,OAAQ,KAGRD,UAAS,oCAGbP,IAIJ,IAAIW,GAAa,EAEjB,MAAMC,EAAU5I,SAAS0B,cAAa,aAChCmH,EAAgB5B,EAA0B2B,EAAO,CAAIpF,mBAAmB,IAExEsF,EAAmB7B,EAA0BO,EAAO,CAAIhE,mBAAmB,IAEjFiE,EAAkB1C,iBAAgB,SAAQ,KACxCyC,EAAQX,UAAUkC,IAAG,wBAErBnK,YAAU,KACR4I,EAAQ/N,iBAAgB,8BAA+B4I,SAASjB,IAC9DA,EAAQ/G,SAAW,KAErBmN,EAAQ5E,MAAK,CAAGC,eAAe,IAC/BiG,EAAiB1D,aAChB,QAGLsC,EAAmB3C,iBAAgB,SAAQ,KACzCyC,EAAQX,UAAUmC,OAAM,wBACxBxB,EAAQ/N,iBAAgB,8BAA+B4I,SAASjB,IAC9DA,EAAQ/G,UAAW,KAErByO,EAAiBxF,gBAGnBkE,EAAQzC,iBAAgB,WAAavF,IACtB,WAATA,EAAMuE,MAGVyD,EAAQX,UAAUmC,OAAM,wBACxBxB,EAAQ/N,iBAAgB,8BAA+B4I,SAASjB,IAC9DA,EAAQ/G,UAAW,KAErByO,EAAiBxF,iBAGnB,MAAM2F,EAAS,KACbN,GAAa,EACTnB,EAAQX,UAAUtJ,SAAQ,0BAC5BiK,EAAQX,UAAUmC,OAAM,wBACxBxB,EAAQ/N,iBAAgB,8BAA+B4I,SAASjB,IAC9DA,EAAQ/G,UAAW,KAErByO,EAAiBxF,cAEnB6D,EAAWN,UAAUmC,OAAM,oCAC3B5B,EAAcP,UAAUmC,OAAM,2BAE9BJ,EAAQnP,iBAAgB,8BAA+B4I,SAASjB,IAC9DA,EAAQ/G,UAAW,KAErBwO,EAAcvF,aAEdtD,SAASkJ,KAAKC,MAAMC,UAAS,QAiBzBC,EAAsBhO,OAAOiO,WAAU,sBAC7CD,EAAoBtE,iBAAgB,UAAS,KACvCsE,EAAoBzQ,QACtBoH,SAASkJ,KAAKC,MAAMC,UAAS,OAG1BT,GAKL3I,SAASkJ,KAAKC,MAAMC,UAAS,SAC7B/N,OAAOkO,SAAQ,CAAGC,IAAK,KALrBxJ,SAASkJ,KAAKC,MAAMC,UAAS,UAQjC,MAAMK,EAAU,KACVd,EACFM,KA9BFN,GAAa,EACbxB,EAAWN,UAAUkC,IAAG,oCACxB3B,EAAcP,UAAUkC,IAAG,2BAE3BH,EAAQnP,iBAAgB,8BAA+B4I,SAASjB,IAC9DA,EAAQ/G,SAAW,KAErBuO,EAAQhG,MAAK,CAAGC,eAAe,IAC/BgG,EAAczD,WAEdpF,SAASkJ,KAAKC,MAAMC,UAAS,WA0B/BjC,EAAWpC,iBAAgB,SAAQ,KACjCsD,IACAI,IACAC,IAEAe,OAGFvC,EAASnC,iBAAgB,SAAQ,KAC3B4D,IACFN,IACAI,IACAC,IAEAO,QAIJL,EAAQ7D,iBAAgB,WAAavF,IAC/BmJ,GAAuB,WAATnJ,EAAMuE,MACtBsE,IACAI,IACAC,IAEAO,QAIoBjJ,SAAS0B,cAAa,yBAC9BqD,iBAAgB,SAAQ,KAClC4D,IACFN,IACAI,IACAC,IAEAO,QAIJ,MAAMS,EAAmBrO,OAAOiO,WAAU,sBACtCI,EAAiB9Q,SACnBgQ,EAAQnP,iBAAgB,8BAA+B4I,SAASjB,IAC9DA,EAAQ/G,SAAW,KAGvBqP,EAAiB3E,iBAAgB,UAAYvF,IAC3CoJ,EAAQnP,iBAAgB,8BAA+B4I,SAASjB,IAC9DA,EAAQ/G,SAAWmF,EAAM5G,QAAU,GAAI,QAM3C,MAAM+Q,EAAwB3J,SAAS0B,cAAa,+CACpD,IAAIkI,EAAe,KAEnB,MAAMC,EAAkB,IAAIC,aAYnBC,EAAWC,EAAOC,GACzBN,EAAsB9C,UAAUmC,OAAM,sDACtCgB,EAAMvQ,iBAAgB,uBAAwB4I,SAASjB,IACrDA,EAAQ/G,UAAW,KAErB2P,EAAMnD,UAAUmC,OAAM,WACtBiB,EAAe3G,iBAIZtD,SAASvG,iBAAgB,sCACzBuG,SAASvG,iBAAgB,yCAC5B4I,SAAS6H,IACT,IAAKA,EAAO1D,QAAQ2D,WAAU,OAG9B,MAAMH,EAAQhK,SAAS0B,cAAa,IAAKwI,EAAO1D,QAAQ2D,cAClDF,EAAiBhD,EAA0B+C,EAAK,CAAIxG,mBAAmB,IAC7EqG,EAAgBO,IAAIJ,EAAOC,GAC3BC,EAAOnF,iBAAgB,SAAQ,aA7BdiF,EAAOC,GACxBN,EAAsB9C,UAAUkC,IAAG,sDACnCiB,EAAMnD,UAAUkC,IAAG,WACnBiB,EAAMvQ,iBAAgB,uBAAwB4I,SAASjB,IACrDA,EAAQ/G,SAAW,KAErB4P,EAAe7E,WACfwE,EAAeI,EAsBwBK,CAAUL,EAAOH,EAAgBS,IAAIN,MAE5EA,EAAMjF,iBAAgB,WAAavF,IACpB,WAATA,EAAMuE,KACRgG,EAAWC,EAAOH,EAAgBS,IAAIN,cAMvChK,SAASvG,iBAAgB,sCACzBuG,SAASvG,iBAAgB,oCAC5B4I,SAAS6H,IACT,IAAKA,EAAO1D,QAAQ+D,YAAW,OAG/B,MAAMP,EAAQhK,SAAS2G,eAAeuD,EAAO1D,QAAQ+D,aACrDL,EAAOnF,iBAAgB,SAAQ,IAAQgF,EAAWC,EAAOH,EAAgBS,IAAIN,SAG/EL,EAAsB5E,iBAAgB,SAAWvF,IAC3CA,EAAMC,SAAWkK,GACnBI,EAAWH,EAAcC,EAAgBS,IAAIV,OAMjD5J,SAASvG,iBAAgB,kCAAmC4I,SAASmI,IACnE,IAAKA,EAAYhE,QAAQiE,iBAAgB,OAGzC,MAAMC,EAAgBF,EAAY9N,cAC5BiO,EAAaD,EAAchJ,cAAa,uCACxCkJ,EAAaF,EAAchJ,cAAa,uCACxCmJ,EAAeH,EAAchJ,cAAa,mCAE1CoJ,EAAW9K,SAAS2G,eAAe6D,EAAYhE,QAAQiE,kBACvDM,EAAcC,OAAOjR,SAAS+Q,EAAStE,QAAQuE,YAAa,IAClEP,EAAYzF,iBAAgB,UAAYvF,QACjCyL,EAAL,KAAyB,QAApBA,EAAAzL,EAAMC,OAAO+G,eAAO,IAApByE,OAAgC,EAAhCA,EAAsBC,YAAU,OAGrC,MAAMA,EAAaF,OAAOjR,SAASyF,EAAMC,OAAO+G,QAAQ0E,WAAY,IAElEP,EAAWxB,MAAM3M,WADA,IAAf0O,EACyB,SAEA,UAEzBA,IAAeH,GACjBH,EAAWzB,MAAM3M,WAAU,SAC3BqO,EAAa1B,MAAM3M,WAAU,YAE7BoO,EAAWzB,MAAM3M,WAAU,UAC3BqO,EAAa1B,MAAM3M,WAAU,UAE/BsO,EAAS3B,MAAMZ,UAAS,eAAsC,KAAlB2C,EAAa,GAAYH,YAIzE/K,SACGvG,iBAAgB,4EAChB4I,SAAS8I,IACR,IAAKA,EAAgB3E,QAAQ4E,YAAW,OAGxC,MAAMC,EAAWL,OAAOjR,SAASoR,EAAgB3E,QAAQ6E,SAAU,IAE7DC,EAAM,IADQtL,SAAS2G,eAAewE,EAAgB3E,QAAQ4E,aACrC3R,iBAAgB,wBAC/C0R,EAAgBpG,iBAAgB,SAAQ,KACtC,MAAMwG,EAAWD,EAAOzM,WAAW2M,GAAUA,EAAM5P,UAAWyP,EAC1DE,GAAY,GAAKA,EAAWD,EAAOvP,SACrCuP,EAAOC,GAAU3P,SAAU,EAC3B0P,EAAOC,GAAUE,cAAc,IAAIC,MAAK,SAAS,CAAIC,SAAS","sources":["node_modules/tabbable/src/index.js","node_modules/focus-trap/index.js","src/index.js"],"sourcesContent":["const candidateSelectors = [\n  'input',\n  'select',\n  'textarea',\n  'a[href]',\n  'button',\n  '[tabindex]',\n  'audio[controls]',\n  'video[controls]',\n  '[contenteditable]:not([contenteditable=\"false\"])',\n  'details>summary:first-of-type',\n  'details',\n];\nconst candidateSelector = /* #__PURE__ */ candidateSelectors.join(',');\n\nconst matches =\n  typeof Element === 'undefined'\n    ? function () {}\n    : Element.prototype.matches ||\n      Element.prototype.msMatchesSelector ||\n      Element.prototype.webkitMatchesSelector;\n\nconst getCandidates = function (el, includeContainer, filter) {\n  let candidates = Array.prototype.slice.apply(\n    el.querySelectorAll(candidateSelector)\n  );\n  if (includeContainer && matches.call(el, candidateSelector)) {\n    candidates.unshift(el);\n  }\n  candidates = candidates.filter(filter);\n  return candidates;\n};\n\nconst isContentEditable = function (node) {\n  return node.contentEditable === 'true';\n};\n\nconst getTabindex = function (node) {\n  const tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);\n\n  if (!isNaN(tabindexAttr)) {\n    return tabindexAttr;\n  }\n\n  // Browsers do not return `tabIndex` correctly for contentEditable nodes;\n  // so if they don't have a tabindex attribute specifically set, assume it's 0.\n  if (isContentEditable(node)) {\n    return 0;\n  }\n\n  // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default\n  //  `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,\n  //  yet they are still part of the regular tab order; in FF, they get a default\n  //  `tabIndex` of 0; since Chrome still puts those elements in the regular tab\n  //  order, consider their tab index to be 0.\n  if (\n    (node.nodeName === 'AUDIO' ||\n      node.nodeName === 'VIDEO' ||\n      node.nodeName === 'DETAILS') &&\n    node.getAttribute('tabindex') === null\n  ) {\n    return 0;\n  }\n\n  return node.tabIndex;\n};\n\nconst sortOrderedTabbables = function (a, b) {\n  return a.tabIndex === b.tabIndex\n    ? a.documentOrder - b.documentOrder\n    : a.tabIndex - b.tabIndex;\n};\n\nconst isInput = function (node) {\n  return node.tagName === 'INPUT';\n};\n\nconst isHiddenInput = function (node) {\n  return isInput(node) && node.type === 'hidden';\n};\n\nconst isDetailsWithSummary = function (node) {\n  const r =\n    node.tagName === 'DETAILS' &&\n    Array.prototype.slice\n      .apply(node.children)\n      .some((child) => child.tagName === 'SUMMARY');\n  return r;\n};\n\nconst getCheckedRadio = function (nodes, form) {\n  for (let i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked && nodes[i].form === form) {\n      return nodes[i];\n    }\n  }\n};\n\nconst isTabbableRadio = function (node) {\n  if (!node.name) {\n    return true;\n  }\n  const radioScope = node.form || node.ownerDocument;\n\n  const queryRadios = function (name) {\n    return radioScope.querySelectorAll(\n      'input[type=\"radio\"][name=\"' + name + '\"]'\n    );\n  };\n\n  let radioSet;\n  if (\n    typeof window !== 'undefined' &&\n    typeof window.CSS !== 'undefined' &&\n    typeof window.CSS.escape === 'function'\n  ) {\n    radioSet = queryRadios(window.CSS.escape(node.name));\n  } else {\n    try {\n      radioSet = queryRadios(node.name);\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.error(\n        'Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s',\n        err.message\n      );\n      return false;\n    }\n  }\n\n  const checked = getCheckedRadio(radioSet, node.form);\n  return !checked || checked === node;\n};\n\nconst isRadio = function (node) {\n  return isInput(node) && node.type === 'radio';\n};\n\nconst isNonTabbableRadio = function (node) {\n  return isRadio(node) && !isTabbableRadio(node);\n};\n\nconst isHidden = function (node, displayCheck) {\n  if (getComputedStyle(node).visibility === 'hidden') {\n    return true;\n  }\n\n  const isDirectSummary = matches.call(node, 'details>summary:first-of-type');\n  const nodeUnderDetails = isDirectSummary ? node.parentElement : node;\n  if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {\n    return true;\n  }\n  if (!displayCheck || displayCheck === 'full') {\n    while (node) {\n      if (getComputedStyle(node).display === 'none') {\n        return true;\n      }\n      node = node.parentElement;\n    }\n  } else if (displayCheck === 'non-zero-area') {\n    const { width, height } = node.getBoundingClientRect();\n    return width === 0 && height === 0;\n  }\n\n  return false;\n};\n\n// form fields (nested) inside a disabled fieldset are not focusable/tabbable\n//  unless they are in the _first_ <legend> element of the top-most disabled\n//  fieldset\nconst isDisabledFromFieldset = function (node) {\n  if (\n    isInput(node) ||\n    node.tagName === 'SELECT' ||\n    node.tagName === 'TEXTAREA' ||\n    node.tagName === 'BUTTON'\n  ) {\n    let parentNode = node.parentElement;\n    while (parentNode) {\n      if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {\n        // look for the first <legend> as an immediate child of the disabled\n        //  <fieldset>: if the node is in that legend, it'll be enabled even\n        //  though the fieldset is disabled; otherwise, the node is in a\n        //  secondary/subsequent legend, or somewhere else within the fieldset\n        //  (however deep nested) and it'll be disabled\n        for (let i = 0; i < parentNode.children.length; i++) {\n          const child = parentNode.children.item(i);\n          if (child.tagName === 'LEGEND') {\n            if (child.contains(node)) {\n              return false;\n            }\n\n            // the node isn't in the first legend (in doc order), so no matter\n            //  where it is now, it'll be disabled\n            return true;\n          }\n        }\n\n        // the node isn't in a legend, so no matter where it is now, it'll be disabled\n        return true;\n      }\n\n      parentNode = parentNode.parentElement;\n    }\n  }\n\n  // else, node's tabbable/focusable state should not be affected by a fieldset's\n  //  enabled/disabled state\n  return false;\n};\n\nconst isNodeMatchingSelectorFocusable = function (options, node) {\n  if (\n    node.disabled ||\n    isHiddenInput(node) ||\n    isHidden(node, options.displayCheck) ||\n    // For a details element with a summary, the summary element gets the focus\n    isDetailsWithSummary(node) ||\n    isDisabledFromFieldset(node)\n  ) {\n    return false;\n  }\n  return true;\n};\n\nconst isNodeMatchingSelectorTabbable = function (options, node) {\n  if (\n    !isNodeMatchingSelectorFocusable(options, node) ||\n    isNonTabbableRadio(node) ||\n    getTabindex(node) < 0\n  ) {\n    return false;\n  }\n  return true;\n};\n\nconst tabbable = function (el, options) {\n  options = options || {};\n\n  const regularTabbables = [];\n  const orderedTabbables = [];\n\n  const candidates = getCandidates(\n    el,\n    options.includeContainer,\n    isNodeMatchingSelectorTabbable.bind(null, options)\n  );\n\n  candidates.forEach(function (candidate, i) {\n    const candidateTabindex = getTabindex(candidate);\n    if (candidateTabindex === 0) {\n      regularTabbables.push(candidate);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        node: candidate,\n      });\n    }\n  });\n\n  const tabbableNodes = orderedTabbables\n    .sort(sortOrderedTabbables)\n    .map((a) => a.node)\n    .concat(regularTabbables);\n\n  return tabbableNodes;\n};\n\nconst focusable = function (el, options) {\n  options = options || {};\n\n  const candidates = getCandidates(\n    el,\n    options.includeContainer,\n    isNodeMatchingSelectorFocusable.bind(null, options)\n  );\n\n  return candidates;\n};\n\nconst isTabbable = function (node, options) {\n  options = options || {};\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, candidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorTabbable(options, node);\n};\n\nconst focusableCandidateSelector = /* #__PURE__ */ candidateSelectors\n  .concat('iframe')\n  .join(',');\n\nconst isFocusable = function (node, options) {\n  options = options || {};\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, focusableCandidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorFocusable(options, node);\n};\n\nexport { tabbable, focusable, isTabbable, isFocusable };\n","import { tabbable, isFocusable } from 'tabbable';\n\nconst activeFocusTraps = (function () {\n  const trapQueue = [];\n  return {\n    activateTrap(trap) {\n      if (trapQueue.length > 0) {\n        const activeTrap = trapQueue[trapQueue.length - 1];\n        if (activeTrap !== trap) {\n          activeTrap.pause();\n        }\n      }\n\n      const trapIndex = trapQueue.indexOf(trap);\n      if (trapIndex === -1) {\n        trapQueue.push(trap);\n      } else {\n        // move this existing trap to the front of the queue\n        trapQueue.splice(trapIndex, 1);\n        trapQueue.push(trap);\n      }\n    },\n\n    deactivateTrap(trap) {\n      const trapIndex = trapQueue.indexOf(trap);\n      if (trapIndex !== -1) {\n        trapQueue.splice(trapIndex, 1);\n      }\n\n      if (trapQueue.length > 0) {\n        trapQueue[trapQueue.length - 1].unpause();\n      }\n    },\n  };\n})();\n\nconst isSelectableInput = function (node) {\n  return (\n    node.tagName &&\n    node.tagName.toLowerCase() === 'input' &&\n    typeof node.select === 'function'\n  );\n};\n\nconst isEscapeEvent = function (e) {\n  return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;\n};\n\nconst isTabEvent = function (e) {\n  return e.key === 'Tab' || e.keyCode === 9;\n};\n\nconst delay = function (fn) {\n  return setTimeout(fn, 0);\n};\n\n// Array.find/findIndex() are not supported on IE; this replicates enough\n//  of Array.findIndex() for our needs\nconst findIndex = function (arr, fn) {\n  let idx = -1;\n\n  arr.every(function (value, i) {\n    if (fn(value)) {\n      idx = i;\n      return false; // break\n    }\n\n    return true; // next\n  });\n\n  return idx;\n};\n\n/**\n * Get an option's value when it could be a plain value, or a handler that provides\n *  the value.\n * @param {*} value Option's value to check.\n * @param {...*} [params] Any parameters to pass to the handler, if `value` is a function.\n * @returns {*} The `value`, or the handler's returned value.\n */\nconst valueOrHandler = function (value, ...params) {\n  return typeof value === 'function' ? value(...params) : value;\n};\n\nconst getActualTarget = function (event) {\n  // NOTE: If the trap is _inside_ a shadow DOM, event.target will always be the\n  //  shadow host. However, event.target.composedPath() will be an array of\n  //  nodes \"clicked\" from inner-most (the actual element inside the shadow) to\n  //  outer-most (the host HTML document). If we have access to composedPath(),\n  //  then use its first element; otherwise, fall back to event.target (and\n  //  this only works for an _open_ shadow DOM; otherwise,\n  //  composedPath()[0] === event.target always).\n  return event.target.shadowRoot && typeof event.composedPath === 'function'\n    ? event.composedPath()[0]\n    : event.target;\n};\n\nconst createFocusTrap = function (elements, userOptions) {\n  const doc = userOptions?.document || document;\n\n  const config = {\n    returnFocusOnDeactivate: true,\n    escapeDeactivates: true,\n    delayInitialFocus: true,\n    ...userOptions,\n  };\n\n  const state = {\n    // @type {Array<HTMLElement>}\n    containers: [],\n\n    // list of objects identifying the first and last tabbable nodes in all containers/groups in\n    //  the trap\n    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap\n    //  is active, but the trap should never get to a state where there isn't at least one group\n    //  with at least one tabbable node in it (that would lead to an error condition that would\n    //  result in an error being thrown)\n    // @type {Array<{ container: HTMLElement, firstTabbableNode: HTMLElement|null, lastTabbableNode: HTMLElement|null }>}\n    tabbableGroups: [],\n\n    nodeFocusedBeforeActivation: null,\n    mostRecentlyFocusedNode: null,\n    active: false,\n    paused: false,\n\n    // timer ID for when delayInitialFocus is true and initial focus in this trap\n    //  has been delayed during activation\n    delayInitialFocusTimer: undefined,\n  };\n\n  let trap; // eslint-disable-line prefer-const -- some private functions reference it, and its methods reference private functions, so we must declare here and define later\n\n  const getOption = (configOverrideOptions, optionName, configOptionName) => {\n    return configOverrideOptions &&\n      configOverrideOptions[optionName] !== undefined\n      ? configOverrideOptions[optionName]\n      : config[configOptionName || optionName];\n  };\n\n  const containersContain = function (element) {\n    return !!(\n      element &&\n      state.containers.some((container) => container.contains(element))\n    );\n  };\n\n  /**\n   * Gets the node for the given option, which is expected to be an option that\n   *  can be either a DOM node, a string that is a selector to get a node, `false`\n   *  (if a node is explicitly NOT given), or a function that returns any of these\n   *  values.\n   * @param {string} optionName\n   * @returns {undefined | false | HTMLElement | SVGElement} Returns\n   *  `undefined` if the option is not specified; `false` if the option\n   *  resolved to `false` (node explicitly not given); otherwise, the resolved\n   *  DOM node.\n   * @throws {Error} If the option is set, not `false`, and is not, or does not\n   *  resolve to a node.\n   */\n  const getNodeForOption = function (optionName, ...params) {\n    let optionValue = config[optionName];\n\n    if (typeof optionValue === 'function') {\n      optionValue = optionValue(...params);\n    }\n\n    if (!optionValue) {\n      if (optionValue === undefined || optionValue === false) {\n        return optionValue;\n      }\n      // else, empty string (invalid), null (invalid), 0 (invalid)\n\n      throw new Error(\n        `\\`${optionName}\\` was specified but was not a node, or did not return a node`\n      );\n    }\n\n    let node = optionValue; // could be HTMLElement, SVGElement, or non-empty string at this point\n\n    if (typeof optionValue === 'string') {\n      node = doc.querySelector(optionValue); // resolve to node, or null if fails\n      if (!node) {\n        throw new Error(\n          `\\`${optionName}\\` as selector refers to no known node`\n        );\n      }\n    }\n\n    return node;\n  };\n\n  const getInitialFocusNode = function () {\n    let node = getNodeForOption('initialFocus');\n\n    // false explicitly indicates we want no initialFocus at all\n    if (node === false) {\n      return false;\n    }\n\n    if (node === undefined) {\n      // option not specified: use fallback options\n      if (containersContain(doc.activeElement)) {\n        node = doc.activeElement;\n      } else {\n        const firstTabbableGroup = state.tabbableGroups[0];\n        const firstTabbableNode =\n          firstTabbableGroup && firstTabbableGroup.firstTabbableNode;\n\n        // NOTE: `fallbackFocus` option function cannot return `false` (not supported)\n        node = firstTabbableNode || getNodeForOption('fallbackFocus');\n      }\n    }\n\n    if (!node) {\n      throw new Error(\n        'Your focus-trap needs to have at least one focusable element'\n      );\n    }\n\n    return node;\n  };\n\n  const updateTabbableNodes = function () {\n    state.tabbableGroups = state.containers\n      .map((container) => {\n        const tabbableNodes = tabbable(container);\n\n        if (tabbableNodes.length > 0) {\n          return {\n            container,\n            firstTabbableNode: tabbableNodes[0],\n            lastTabbableNode: tabbableNodes[tabbableNodes.length - 1],\n          };\n        }\n\n        return undefined;\n      })\n      .filter((group) => !!group); // remove groups with no tabbable nodes\n\n    // throw if no groups have tabbable nodes and we don't have a fallback focus node either\n    if (\n      state.tabbableGroups.length <= 0 &&\n      !getNodeForOption('fallbackFocus') // returning false not supported for this option\n    ) {\n      throw new Error(\n        'Your focus-trap must have at least one container with at least one tabbable node in it at all times'\n      );\n    }\n  };\n\n  const tryFocus = function (node) {\n    if (node === false) {\n      return;\n    }\n\n    if (node === doc.activeElement) {\n      return;\n    }\n\n    if (!node || !node.focus) {\n      tryFocus(getInitialFocusNode());\n      return;\n    }\n\n    node.focus({ preventScroll: !!config.preventScroll });\n    state.mostRecentlyFocusedNode = node;\n\n    if (isSelectableInput(node)) {\n      node.select();\n    }\n  };\n\n  const getReturnFocusNode = function (previousActiveElement) {\n    const node = getNodeForOption('setReturnFocus', previousActiveElement);\n    return node ? node : node === false ? false : previousActiveElement;\n  };\n\n  // This needs to be done on mousedown and touchstart instead of click\n  // so that it precedes the focus event.\n  const checkPointerDown = function (e) {\n    const target = getActualTarget(e);\n\n    if (containersContain(target)) {\n      // allow the click since it ocurred inside the trap\n      return;\n    }\n\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      // immediately deactivate the trap\n      trap.deactivate({\n        // if, on deactivation, we should return focus to the node originally-focused\n        //  when the trap was activated (or the configured `setReturnFocus` node),\n        //  then assume it's also OK to return focus to the outside node that was\n        //  just clicked, causing deactivation, as long as that node is focusable;\n        //  if it isn't focusable, then return focus to the original node focused\n        //  on activation (or the configured `setReturnFocus` node)\n        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,\n        //  which will result in the outside click setting focus to the node\n        //  that was clicked, whether it's focusable or not; by setting\n        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused\n        //  on activation (or the configured `setReturnFocus` node)\n        returnFocus: config.returnFocusOnDeactivate && !isFocusable(target),\n      });\n      return;\n    }\n\n    // This is needed for mobile devices.\n    // (If we'll only let `click` events through,\n    // then on mobile they will be blocked anyways if `touchstart` is blocked.)\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      // allow the click outside the trap to take place\n      return;\n    }\n\n    // otherwise, prevent the click\n    e.preventDefault();\n  };\n\n  // In case focus escapes the trap for some strange reason, pull it back in.\n  const checkFocusIn = function (e) {\n    const target = getActualTarget(e);\n    const targetContained = containersContain(target);\n\n    // In Firefox when you Tab out of an iframe the Document is briefly focused.\n    if (targetContained || target instanceof Document) {\n      if (targetContained) {\n        state.mostRecentlyFocusedNode = target;\n      }\n    } else {\n      // escaped! pull it back in to where it just left\n      e.stopImmediatePropagation();\n      tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());\n    }\n  };\n\n  // Hijack Tab events on the first and last focusable nodes of the trap,\n  // in order to prevent focus from escaping. If it escapes for even a\n  // moment it can end up scrolling the page and causing confusion so we\n  // kind of need to capture the action at the keydown phase.\n  const checkTab = function (e) {\n    const target = getActualTarget(e);\n    updateTabbableNodes();\n\n    let destinationNode = null;\n\n    if (state.tabbableGroups.length > 0) {\n      // make sure the target is actually contained in a group\n      // NOTE: the target may also be the container itself if it's tabbable\n      //  with tabIndex='-1' and was given initial focus\n      const containerIndex = findIndex(state.tabbableGroups, ({ container }) =>\n        container.contains(target)\n      );\n\n      if (containerIndex < 0) {\n        // target not found in any group: quite possible focus has escaped the trap,\n        //  so bring it back in to...\n        if (e.shiftKey) {\n          // ...the last node in the last group\n          destinationNode =\n            state.tabbableGroups[state.tabbableGroups.length - 1]\n              .lastTabbableNode;\n        } else {\n          // ...the first node in the first group\n          destinationNode = state.tabbableGroups[0].firstTabbableNode;\n        }\n      } else if (e.shiftKey) {\n        // REVERSE\n\n        // is the target the first tabbable node in a group?\n        let startOfGroupIndex = findIndex(\n          state.tabbableGroups,\n          ({ firstTabbableNode }) => target === firstTabbableNode\n        );\n\n        if (\n          startOfGroupIndex < 0 &&\n          state.tabbableGroups[containerIndex].container === target\n        ) {\n          // an exception case where the target is the container itself, in which\n          //  case, we should handle shift+tab as if focus were on the container's\n          //  first tabbable node, and go to the last tabbable node of the LAST group\n          startOfGroupIndex = containerIndex;\n        }\n\n        if (startOfGroupIndex >= 0) {\n          // YES: then shift+tab should go to the last tabbable node in the\n          //  previous group (and wrap around to the last tabbable node of\n          //  the LAST group if it's the first tabbable node of the FIRST group)\n          const destinationGroupIndex =\n            startOfGroupIndex === 0\n              ? state.tabbableGroups.length - 1\n              : startOfGroupIndex - 1;\n\n          const destinationGroup = state.tabbableGroups[destinationGroupIndex];\n          destinationNode = destinationGroup.lastTabbableNode;\n        }\n      } else {\n        // FORWARD\n\n        // is the target the last tabbable node in a group?\n        let lastOfGroupIndex = findIndex(\n          state.tabbableGroups,\n          ({ lastTabbableNode }) => target === lastTabbableNode\n        );\n\n        if (\n          lastOfGroupIndex < 0 &&\n          state.tabbableGroups[containerIndex].container === target\n        ) {\n          // an exception case where the target is the container itself, in which\n          //  case, we should handle tab as if focus were on the container's\n          //  last tabbable node, and go to the first tabbable node of the FIRST group\n          lastOfGroupIndex = containerIndex;\n        }\n\n        if (lastOfGroupIndex >= 0) {\n          // YES: then tab should go to the first tabbable node in the next\n          //  group (and wrap around to the first tabbable node of the FIRST\n          //  group if it's the last tabbable node of the LAST group)\n          const destinationGroupIndex =\n            lastOfGroupIndex === state.tabbableGroups.length - 1\n              ? 0\n              : lastOfGroupIndex + 1;\n\n          const destinationGroup = state.tabbableGroups[destinationGroupIndex];\n          destinationNode = destinationGroup.firstTabbableNode;\n        }\n      }\n    } else {\n      // NOTE: the fallbackFocus option does not support returning false to opt-out\n      destinationNode = getNodeForOption('fallbackFocus');\n    }\n\n    if (destinationNode) {\n      e.preventDefault();\n      tryFocus(destinationNode);\n    }\n    // else, let the browser take care of [shift+]tab and move the focus\n  };\n\n  const checkKey = function (e) {\n    if (\n      isEscapeEvent(e) &&\n      valueOrHandler(config.escapeDeactivates, e) !== false\n    ) {\n      e.preventDefault();\n      trap.deactivate();\n      return;\n    }\n\n    if (isTabEvent(e)) {\n      checkTab(e);\n      return;\n    }\n  };\n\n  const checkClick = function (e) {\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      return;\n    }\n\n    const target = getActualTarget(e);\n\n    if (containersContain(target)) {\n      return;\n    }\n\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      return;\n    }\n\n    e.preventDefault();\n    e.stopImmediatePropagation();\n  };\n\n  //\n  // EVENT LISTENERS\n  //\n\n  const addListeners = function () {\n    if (!state.active) {\n      return;\n    }\n\n    // There can be only one listening focus trap at a time\n    activeFocusTraps.activateTrap(trap);\n\n    // Delay ensures that the focused element doesn't capture the event\n    // that caused the focus trap activation.\n    state.delayInitialFocusTimer = config.delayInitialFocus\n      ? delay(function () {\n          tryFocus(getInitialFocusNode());\n        })\n      : tryFocus(getInitialFocusNode());\n\n    doc.addEventListener('focusin', checkFocusIn, true);\n    doc.addEventListener('mousedown', checkPointerDown, {\n      capture: true,\n      passive: false,\n    });\n    doc.addEventListener('touchstart', checkPointerDown, {\n      capture: true,\n      passive: false,\n    });\n    doc.addEventListener('click', checkClick, {\n      capture: true,\n      passive: false,\n    });\n    doc.addEventListener('keydown', checkKey, {\n      capture: true,\n      passive: false,\n    });\n\n    return trap;\n  };\n\n  const removeListeners = function () {\n    if (!state.active) {\n      return;\n    }\n\n    doc.removeEventListener('focusin', checkFocusIn, true);\n    doc.removeEventListener('mousedown', checkPointerDown, true);\n    doc.removeEventListener('touchstart', checkPointerDown, true);\n    doc.removeEventListener('click', checkClick, true);\n    doc.removeEventListener('keydown', checkKey, true);\n\n    return trap;\n  };\n\n  //\n  // TRAP DEFINITION\n  //\n\n  trap = {\n    activate(activateOptions) {\n      if (state.active) {\n        return this;\n      }\n\n      const onActivate = getOption(activateOptions, 'onActivate');\n      const onPostActivate = getOption(activateOptions, 'onPostActivate');\n      const checkCanFocusTrap = getOption(activateOptions, 'checkCanFocusTrap');\n\n      if (!checkCanFocusTrap) {\n        updateTabbableNodes();\n      }\n\n      state.active = true;\n      state.paused = false;\n      state.nodeFocusedBeforeActivation = doc.activeElement;\n\n      if (onActivate) {\n        onActivate();\n      }\n\n      const finishActivation = () => {\n        if (checkCanFocusTrap) {\n          updateTabbableNodes();\n        }\n        addListeners();\n        if (onPostActivate) {\n          onPostActivate();\n        }\n      };\n\n      if (checkCanFocusTrap) {\n        checkCanFocusTrap(state.containers.concat()).then(\n          finishActivation,\n          finishActivation\n        );\n        return this;\n      }\n\n      finishActivation();\n      return this;\n    },\n\n    deactivate(deactivateOptions) {\n      if (!state.active) {\n        return this;\n      }\n\n      clearTimeout(state.delayInitialFocusTimer); // noop if undefined\n      state.delayInitialFocusTimer = undefined;\n\n      removeListeners();\n      state.active = false;\n      state.paused = false;\n\n      activeFocusTraps.deactivateTrap(trap);\n\n      const onDeactivate = getOption(deactivateOptions, 'onDeactivate');\n      const onPostDeactivate = getOption(deactivateOptions, 'onPostDeactivate');\n      const checkCanReturnFocus = getOption(\n        deactivateOptions,\n        'checkCanReturnFocus'\n      );\n\n      if (onDeactivate) {\n        onDeactivate();\n      }\n\n      const returnFocus = getOption(\n        deactivateOptions,\n        'returnFocus',\n        'returnFocusOnDeactivate'\n      );\n\n      const finishDeactivation = () => {\n        delay(() => {\n          if (returnFocus) {\n            tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));\n          }\n          if (onPostDeactivate) {\n            onPostDeactivate();\n          }\n        });\n      };\n\n      if (returnFocus && checkCanReturnFocus) {\n        checkCanReturnFocus(\n          getReturnFocusNode(state.nodeFocusedBeforeActivation)\n        ).then(finishDeactivation, finishDeactivation);\n        return this;\n      }\n\n      finishDeactivation();\n      return this;\n    },\n\n    pause() {\n      if (state.paused || !state.active) {\n        return this;\n      }\n\n      state.paused = true;\n      removeListeners();\n\n      return this;\n    },\n\n    unpause() {\n      if (!state.paused || !state.active) {\n        return this;\n      }\n\n      state.paused = false;\n      updateTabbableNodes();\n      addListeners();\n\n      return this;\n    },\n\n    updateContainerElements(containerElements) {\n      const elementsAsArray = [].concat(containerElements).filter(Boolean);\n\n      state.containers = elementsAsArray.map((element) =>\n        typeof element === 'string' ? doc.querySelector(element) : element\n      );\n\n      if (state.active) {\n        updateTabbableNodes();\n      }\n\n      return this;\n    },\n  };\n\n  // initialize container elements\n  trap.updateContainerElements(elements);\n\n  return trap;\n};\n\nexport { createFocusTrap };\n","import * as focusTrap from 'focus-trap';\n\ndocument.querySelectorAll('[data-toggles-class]').forEach((toggler) => {\n  const className = toggler.dataset.togglesClass;\n  const classToggleTarget = document.getElementById(toggler.dataset.togglesClassFor);\n\n  toggler.addEventListener('click', () => {\n    classToggleTarget.classList.toggle(className);\n  });\n});\n\nconst cookiesModal = document.getElementById('cookies-pop-up');\ncookiesModal.focus();\nconst cookiesModalTrap = focusTrap.createFocusTrap(cookiesModal, { allowOutsideClick: true });\ncookiesModalTrap.activate();\nconst cookiesModalCloseButton = cookiesModal.querySelector('.cookies-pop-up__agree-button');\ncookiesModalCloseButton.addEventListener('click', () => {\n  cookiesModalTrap.deactivate();\n});\ncookiesModal.addEventListener('keydown', (event) => {\n  if (event.key === 'Escape') {\n    cookiesModal.classList.toggle('cookies-pop-up_hidden');\n  }\n});\n\ndocument.querySelectorAll('[data-focus-hidden=\"true\"]').forEach((element) => {\n  element.tabIndex = -1;\n});\n\nconst pageMain = document.querySelector('.page-main');\n\nconst menuButton = document.querySelector('.page-header-top-bar__menu-button');\nconst pageNavDarken = document.querySelector('.page-nav-darken');\n\nconst topBar = menuButton.querySelector('.burger-icon__top');\nconst middleBar = menuButton.querySelector('.burger-icon__middle');\nconst bottomBar = menuButton.querySelector('.burger-icon__bottom');\n\nconst submenu = document.querySelector('.menu-sub-nav');\nconst submenuOpenButton = document.querySelector('.nav-list__open-submenu-button');\nconst submenuCloseButton = document.querySelector('.menu-sub-nav__go-back-button');\n\nconst playBackAndForth = (animation) => {\n  if (animation === undefined) {\n    return () => {};\n  }\n\n  let playingFirstTime = true;\n  animation.pause();\n\n  return () => {\n    if (playingFirstTime) {\n      playingFirstTime = false;\n    } else {\n      animation.reverse();\n    }\n    animation.play();\n  };\n};\n\nconst animationOptions = {\n  direction: 'normal',\n  fill: 'forwards',\n  duration: 300,\n  easing: 'ease-in-out',\n};\n\nconst topBarAnimation = playBackAndForth(\n  topBar.animate(\n    [\n      {\n        transform: 'none',\n      },\n      {\n        transform: 'translateY(30%)',\n        offset: 0.3,\n      },\n      {\n        transform: 'translateY(30%)',\n        offset: 0.6,\n      },\n      {\n        transform: 'translateY(30%) rotate(45deg)',\n      },\n    ],\n    animationOptions,\n  ),\n);\n\nconst middleBarAnimation = playBackAndForth(\n  middleBar.animate(\n    [\n      {\n        transform: 'none',\n      },\n      {\n        transform: 'none',\n        offset: 0.3,\n      },\n      {\n        transform: 'none',\n        offset: 0.6,\n      },\n      {\n        transform: 'rotate(45deg)',\n      },\n    ],\n    animationOptions,\n  ),\n);\n\nconst bottomBarAnimation = playBackAndForth(\n  bottomBar.animate(\n    [\n      {\n        transform: 'none',\n      },\n      {\n        transform: 'translateY(-30%)',\n        offset: 0.3,\n      },\n      {\n        transform: 'translateY(-30%)',\n        offset: 0.6,\n      },\n      {\n        transform: 'translateY(-30%) rotate(135deg)',\n      },\n    ],\n    animationOptions,\n  ),\n);\n\nlet menuOpened = false;\n\nconst navList = document.querySelector('.page-nav');\nconst menuFocusTrap = focusTrap.createFocusTrap(navList, { allowOutsideClick: true });\n\nconst submenuFocusTrap = focusTrap.createFocusTrap(submenu, { allowOutsideClick: true });\n\nsubmenuOpenButton.addEventListener('click', () => {\n  submenu.classList.add('menu-sub-nav_toggled');\n\n  setTimeout(() => {\n    submenu.querySelectorAll('[data-focus-hidden=\"true\"]').forEach((element) => {\n      element.tabIndex = 0;\n    });\n    submenu.focus({ preventScroll: true });\n    submenuFocusTrap.activate();\n  }, 200);\n});\n\nsubmenuCloseButton.addEventListener('click', () => {\n  submenu.classList.remove('menu-sub-nav_toggled');\n  submenu.querySelectorAll('[data-focus-hidden=\"true\"]').forEach((element) => {\n    element.tabIndex = -1;\n  });\n  submenuFocusTrap.deactivate();\n});\n\nsubmenu.addEventListener('keydown', (event) => {\n  if (event.key !== 'Escape') {\n    return;\n  }\n  submenu.classList.remove('menu-sub-nav_toggled');\n  submenu.querySelectorAll('[data-focus-hidden=\"true\"]').forEach((element) => {\n    element.tabIndex = -1;\n  });\n  submenuFocusTrap.deactivate();\n});\n\nconst closeMenu = () => {\n  menuOpened = false;\n  if (submenu.classList.contains('menu-sub-nav_toggled')) {\n    submenu.classList.remove('menu-sub-nav_toggled');\n    submenu.querySelectorAll('[data-focus-hidden=\"true\"]').forEach((element) => {\n      element.tabIndex = -1;\n    });\n    submenuFocusTrap.deactivate();\n  }\n  menuButton.classList.remove('page-header__menu-button_toggled');\n  pageNavDarken.classList.remove('page-nav-darken_toggled');\n\n  navList.querySelectorAll('[data-focus-hidden=\"true\"]').forEach((element) => {\n    element.tabIndex = -1;\n  });\n  menuFocusTrap.deactivate();\n\n  document.body.style.overflowY = 'auto';\n};\n\nconst openMenu = () => {\n  menuOpened = true;\n  menuButton.classList.add('page-header__menu-button_toggled');\n  pageNavDarken.classList.add('page-nav-darken_toggled');\n\n  navList.querySelectorAll('[data-focus-hidden=\"true\"]').forEach((element) => {\n    element.tabIndex = 0;\n  });\n  navList.focus({ preventScroll: true });\n  menuFocusTrap.activate();\n\n  document.body.style.overflowY = 'hidden';\n};\n\nconst scrollBarMediaQuery = window.matchMedia('(min-width: 50rem)');\nscrollBarMediaQuery.addEventListener('change', () => {\n  if (scrollBarMediaQuery.matches) {\n    document.body.style.overflowY = 'auto';\n    return;\n  }\n  if (!menuOpened) {\n    document.body.style.overflowY = 'auto';\n    return;\n  }\n\n  document.body.style.overflowY = 'hidden';\n  window.scrollTo({ top: 0 });\n});\n\nconst toggleMenu = () => {\n  if (menuOpened) {\n    closeMenu();\n  } else {\n    openMenu();\n  }\n};\n\nmenuButton.addEventListener('click', () => {\n  topBarAnimation();\n  middleBarAnimation();\n  bottomBarAnimation();\n\n  toggleMenu();\n});\n\npageMain.addEventListener('click', () => {\n  if (menuOpened) {\n    topBarAnimation();\n    middleBarAnimation();\n    bottomBarAnimation();\n\n    closeMenu();\n  }\n});\n\nnavList.addEventListener('keydown', (event) => {\n  if (menuOpened && event.key === 'Escape') {\n    topBarAnimation();\n    middleBarAnimation();\n    bottomBarAnimation();\n\n    closeMenu();\n  }\n});\n\nconst menuCloseButton = document.querySelector('.page-nav__close-menu');\nmenuCloseButton.addEventListener('click', () => {\n  if (menuOpened) {\n    topBarAnimation();\n    middleBarAnimation();\n    bottomBarAnimation();\n\n    closeMenu();\n  }\n});\n\nconst largeScreenMedia = window.matchMedia('(min-width: 50rem)');\nif (largeScreenMedia.matches) {\n  navList.querySelectorAll('[data-focus-hidden=\"true\"]').forEach((element) => {\n    element.tabIndex = 0;\n  });\n}\nlargeScreenMedia.addEventListener('change', (event) => {\n  navList.querySelectorAll('[data-focus-hidden=\"true\"]').forEach((element) => {\n    element.tabIndex = event.matches ? 0 : -1;\n  });\n});\n\n// modals\n\nconst learnMoreModalOverlay = document.querySelector('.endless-extras-section__learn-more-overlay');\nlet currentModal = null;\n\nconst modalFocusTraps = new Map();\n\nfunction openModal(modal, modalFocusTrap) {\n  learnMoreModalOverlay.classList.add('endless-extras-section__learn-more-overlay_toggled');\n  modal.classList.add('toggled');\n  modal.querySelectorAll('[data-focus-hidden]').forEach((element) => {\n    element.tabIndex = 0;\n  });\n  modalFocusTrap.activate();\n  currentModal = modal;\n}\n\nfunction closeModal(modal, modalFocusTrap) {\n  learnMoreModalOverlay.classList.remove('endless-extras-section__learn-more-overlay_toggled');\n  modal.querySelectorAll('[data-focus-hidden]').forEach((element) => {\n    element.tabIndex = -1;\n  });\n  modal.classList.remove('toggled');\n  modalFocusTrap.deactivate();\n}\n\n[\n  ...document.querySelectorAll('.extras-item__learn-more-button'),\n  ...document.querySelectorAll('.extras-item_learn-more-image-button'),\n].forEach((button) => {\n  if (!button.dataset.opensModal) {\n    return;\n  }\n  const modal = document.querySelector(`#${button.dataset.opensModal}`);\n  const modalFocusTrap = focusTrap.createFocusTrap(modal, { allowOutsideClick: true });\n  modalFocusTraps.set(modal, modalFocusTrap);\n  button.addEventListener('click', () => openModal(modal, modalFocusTraps.get(modal)));\n\n  modal.addEventListener('keydown', (event) => {\n    if (event.key === 'Escape') {\n      closeModal(modal, modalFocusTraps.get(modal));\n    }\n  });\n});\n\n[\n  ...document.querySelectorAll('.learn-more-modal__accept-modal'),\n  ...document.querySelectorAll('.learn-more-modal__close-button'),\n].forEach((button) => {\n  if (!button.dataset.closesModal) {\n    return;\n  }\n  const modal = document.getElementById(button.dataset.closesModal);\n  button.addEventListener('click', () => closeModal(modal, modalFocusTraps.get(modal)));\n});\n\nlearnMoreModalOverlay.addEventListener('click', (event) => {\n  if (event.target === learnMoreModalOverlay) {\n    closeModal(currentModal, modalFocusTraps.get(currentModal));\n  }\n});\n\n// carousel\n\ndocument.querySelectorAll('.learn-more-modal__page-radios').forEach((radiosBlock) => {\n  if (!radiosBlock.dataset.controlsCarousel) {\n    return;\n  }\n  const controlsBlock = radiosBlock.parentElement;\n  const prevButton = controlsBlock.querySelector('.learn-more-modal__prev-page-button');\n  const nextButton = controlsBlock.querySelector('.learn-more-modal__next-page-button');\n  const acceptButton = controlsBlock.querySelector('.learn-more-modal__accept-modal');\n\n  const carousel = document.getElementById(radiosBlock.dataset.controlsCarousel);\n  const slidesCount = Number.parseInt(carousel.dataset.slidesCount, 10);\n  radiosBlock.addEventListener('change', (event) => {\n    if (!event.target.dataset?.pageNumber) {\n      return;\n    }\n    const pageNumber = Number.parseInt(event.target.dataset.pageNumber, 10);\n    if (pageNumber === 1) {\n      prevButton.style.visibility = 'hidden';\n    } else {\n      prevButton.style.visibility = 'visible';\n    }\n    if (pageNumber === slidesCount) {\n      nextButton.style.visibility = 'hidden';\n      acceptButton.style.visibility = 'visible';\n    } else {\n      nextButton.style.visibility = 'visible';\n      acceptButton.style.visibility = 'hidden';\n    }\n    carousel.style.transform = `translateX(-${((pageNumber - 1) * 100) / slidesCount}%)`;\n  });\n});\n\ndocument\n  .querySelectorAll('.learn-more-modal__prev-page-button, .learn-more-modal__next-page-button')\n  .forEach((shiftPageButton) => {\n    if (!shiftPageButton.dataset.selectsFrom) {\n      return;\n    }\n    const shiftsBy = Number.parseInt(shiftPageButton.dataset.shiftsBy, 10);\n    const radiosBlock = document.getElementById(shiftPageButton.dataset.selectsFrom);\n    const radios = [...radiosBlock.querySelectorAll('input[type=\"radio\"]')];\n    shiftPageButton.addEventListener('click', () => {\n      const nextPage = radios.findIndex((radio) => radio.checked) + shiftsBy;\n      if (nextPage >= 0 && nextPage < radios.length) {\n        radios[nextPage].checked = true;\n        radios[nextPage].dispatchEvent(new Event('change', { bubbles: true }));\n      }\n    });\n  });\n"],"names":["candidateSelectors","candidateSelector","join","matches","Element","prototype","msMatchesSelector","webkitMatchesSelector","getCandidates","el","includeContainer","filter","candidates","Array","slice","apply","querySelectorAll","call","unshift","getTabindex","node","tabindexAttr","parseInt","getAttribute","isNaN","contentEditable","isContentEditable","nodeName","tabIndex","sortOrderedTabbables","a","b","documentOrder","isInput","tagName","isNonTabbableRadio","type","isRadio","name","radioSet","radioScope","form","ownerDocument","queryRadios","window","CSS","escape","err","console","error","message","checked","nodes","i","length","getCheckedRadio","isTabbableRadio","isNodeMatchingSelectorFocusable","options","disabled","isHiddenInput","displayCheck","getComputedStyle","visibility","nodeUnderDetails","parentElement","_node$getBoundingClie","getBoundingClientRect","width","height","display","isHidden","children","some","child","isDetailsWithSummary","parentNode","item","contains","isDisabledFromFieldset","isNodeMatchingSelectorTabbable","focusableCandidateSelector","concat","isFocusable","Error","trapQueue","activeFocusTraps","activateTrap","trap","activeTrap","pause","trapIndex","indexOf","splice","push","deactivateTrap","unpause","delay","fn","setTimeout","findIndex","arr","idx","every","value","valueOrHandler","_len","arguments","params","_key","getActualTarget","event","target","shadowRoot","composedPath","createFocusTrap","elements","userOptions","doc","document","config","$cfcba6284bd82209$var$_objectSpread2","returnFocusOnDeactivate","escapeDeactivates","delayInitialFocus","state","containers","tabbableGroups","nodeFocusedBeforeActivation","mostRecentlyFocusedNode","active","paused","delayInitialFocusTimer","undefined","getOption","configOverrideOptions","optionName","configOptionName","containersContain","element","container","getNodeForOption","optionValue","_len2","_key2","querySelector","getInitialFocusNode","activeElement","firstTabbableGroup","firstTabbableNode","updateTabbableNodes","map","regularTabbables","orderedTabbables","tabbableNodes","bind","forEach","candidate","candidateTabindex","sort","lastTabbableNode","group","tryFocus","focus","preventScroll","toLowerCase","select","isSelectableInput","getReturnFocusNode","previousActiveElement","checkPointerDown","e","clickOutsideDeactivates","deactivate","returnFocus","allowOutsideClick","preventDefault","checkFocusIn","targetContained","Document","stopImmediatePropagation","checkKey","key","keyCode","isEscapeEvent","isTabEvent","destinationNode","containerIndex","_ref","shiftKey","startOfGroupIndex","_ref2","destinationGroupIndex","lastOfGroupIndex","_ref3","checkTab","checkClick","addListeners","addEventListener","capture","passive","removeListeners","removeEventListener","activate","activateOptions","this","onActivate","onPostActivate","checkCanFocusTrap","finishActivation","then","deactivateOptions","clearTimeout","onDeactivate","onPostDeactivate","checkCanReturnFocus","finishDeactivation","updateContainerElements","containerElements","elementsAsArray","Boolean","toggler","className","dataset","togglesClass","classToggleTarget","getElementById","togglesClassFor","classList","toggle","$77574c51a0e0561b$var$cookiesModal","$77574c51a0e0561b$var$cookiesModalTrap","$cfcba6284bd82209$export$fcb07c927a49286e","$77574c51a0e0561b$var$pageMain","$77574c51a0e0561b$var$menuButton","$77574c51a0e0561b$var$pageNavDarken","$77574c51a0e0561b$var$topBar","$77574c51a0e0561b$var$middleBar","$77574c51a0e0561b$var$bottomBar","$77574c51a0e0561b$var$submenu","$77574c51a0e0561b$var$submenuOpenButton","$77574c51a0e0561b$var$submenuCloseButton","$77574c51a0e0561b$var$playBackAndForth","animation","playingFirstTime","reverse","play","$77574c51a0e0561b$var$animationOptions","direction","fill","duration","easing","$77574c51a0e0561b$var$topBarAnimation","animate","transform","offset","$77574c51a0e0561b$var$middleBarAnimation","$77574c51a0e0561b$var$bottomBarAnimation","$77574c51a0e0561b$var$menuOpened","$77574c51a0e0561b$var$navList","$77574c51a0e0561b$var$menuFocusTrap","$77574c51a0e0561b$var$submenuFocusTrap","add","remove","$77574c51a0e0561b$var$closeMenu","body","style","overflowY","$77574c51a0e0561b$var$scrollBarMediaQuery","matchMedia","scrollTo","top","$77574c51a0e0561b$var$toggleMenu","$77574c51a0e0561b$var$largeScreenMedia","$77574c51a0e0561b$var$learnMoreModalOverlay","$77574c51a0e0561b$var$currentModal","$77574c51a0e0561b$var$modalFocusTraps","Map","$77574c51a0e0561b$var$closeModal","modal","modalFocusTrap","button","opensModal","set","$77574c51a0e0561b$var$openModal","get","closesModal","radiosBlock","controlsCarousel","controlsBlock","prevButton","nextButton","acceptButton","carousel","slidesCount","Number","ref","pageNumber","shiftPageButton","selectsFrom","shiftsBy","radios","nextPage","radio","dispatchEvent","Event","bubbles"],"version":3,"file":"index.60d40d97.js.map"}